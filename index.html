<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Libro 3D Curvado - Three.js</title>
<style>
  html,body { height:100%; margin:0; background:#f7efe3; font-family: Georgia, "Times New Roman", serif; }
  #container { width:100%; height:100vh; display:flex; align-items:center; justify-content:center; overflow:hidden; }
  canvas { display:block; }

  /* P√°ginas originales (fuente de textura). Oculto */
  #page-source { position:fixed; left:-9999px; top:-9999px; visibility:hidden; }
  .page { width: 800px; height: 500px; box-sizing:border-box; background:white; padding:30px; font-size:18px; line-height:1.6; }
  .cover h1 { color:#c2185b; font-size:28px; margin:0 0 10px; text-align:center; }
  .final-page img { max-width:70%; display:block; margin:12px auto; }

  /* UI */
  #ui { position: fixed; right: 18px; bottom: 18px; display:flex; gap:8px; z-index: 20; }
  .btn {
    background: #fff; border-radius:8px; padding:8px 12px; box-shadow:0 2px 8px rgba(0,0,0,0.18);
    cursor:pointer; user-select:none;
  }
</style>
</head>
<body>

<div id="container"></div>

<!-- Fuente: tus p√°ginas (ocultas) -->
<div id="page-source">
  <div class="page cover">
    <h1>üíå Feliz 10 meses amor...</h1>
    <p>Hoy quiero decirte que...</p>
  </div>

  <div class="page">
    Que siento miles de cosas en mi cabeza cada vez que te escucho hablarme bonito o de las cosas que te pasan, por m√°s que estos 10 meses no han pasado muchas cosas siento que te amo much√≠simo m√°s que desde un inicio y es algo s√∫per bonito y espero que‚Ä¶.
  </div>

  <div class="page">
    Te hayas dado cuenta de algo‚Ä¶ ese algo es lo lindo y especial que es pasar tiempo juntos por m√°s que sea tras una pantalla, sos todo lo que necesito en mi vida y la ni√±a que m√°s amar√© y me acordar√© si es que alg√∫n d√≠a pasa algo, yo a ti te valoro y te respeto un mont√≥n, tal vez alg√∫n d√≠a diremos "la distancia vali√≥ la pena".
    <br><br>
    El llegar a 10 meses en una relaci√≥n no es f√°cil, han pasado muchas cosas pero nunca pienso retroceder con vos, siento que encontr√© todo con vos y no te pienso soltar por solo un error de cualquiera de los dos. Tenemos demasiadas cosas en com√∫n pero algo que destaco es el escuchar y la comunicaci√≥n por m√°s que a veces nos cueste. Esto que pas√≥ hace poco del beso y no s√© qu√© m√°s espero que‚Ä¶.
  </div>

  <div class="page final-page">
    <img src="./62b22f0d-d406-4bfa-af30-7add598e73d9.jpg" alt="Snoopy adorable">
    <p>
      No hayas pensado que eso puede decirme que sos una mala persona o que te ame menos por lo que pas√≥...
    </p>
  </div>
</div>

<!-- UI -->
<div id="ui">
  <div class="btn" id="prevBtn">‚óÄ Anterior</div>
  <div class="btn" id="nextBtn">Siguiente ‚ñ∂</div>
  <div class="btn" id="resetBtn">‚Ü∫ Reset</div>
</div>

<!-- Librer√≠as -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/examples/js/controls/OrbitControls.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
/*
  Implementaci√≥n:
  - Cada p√°gina usa la misma geometr√≠a subdividida (widthSegments controls suavidad).
  - En la animaci√≥n de flip se interpola un "progress" 0->1 y deformamos v√©rtices
    en funci√≥n de su distancia al lomo (hinge), aplicando una curva tipo "curl".
  - BackFace es una segunda malla que comparte la geometr√≠a para mantener sincron√≠a.
*/

(async () => {

  // ---- 1) Capturar p√°ginas como im√°genes (texturas) ----
  const pageDivs = Array.from(document.querySelectorAll('#page-source .page'));
  const pageImgs = [];
  for (let i=0;i<pageDivs.length;i++){
    // render a escala 2 para mejor nitidez
    const canvas = await html2canvas(pageDivs[i], {width:800, height:500, scale:2, backgroundColor:null});
    pageImgs.push(canvas.toDataURL('image/png'));
  }

  // ---- 2) Three.js setup ----
  const container = document.getElementById('container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf7efe3);

  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  container.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 3000);
  camera.position.set(0, 60, 420);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enablePan = false;
  controls.minDistance = 300; controls.maxDistance = 900;
  controls.maxPolarAngle = Math.PI/2.3;

  // luces
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.85); hemi.position.set(0,200,0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(120,200,120); scene.add(dir);

  // libro grupo
  const book = new THREE.Group();
  scene.add(book);

  // par√°metros de mapa f√≠sico vs escena
  const PAGE_PIXEL_W = 800, PAGE_PIXEL_H = 500;
  // tama√±o visual en la escena (ajusta para est√©tica)
  const PAGE_W = 200;
  const PAGE_H = PAGE_W * (PAGE_PIXEL_H / PAGE_PIXEL_W); // mant√©n proporci√≥n
  const WIDTH_SEGMENTS = 60; // <--- subdivisiones horizontales (suavidad de curvado)
  const HEIGHT_SEGMENTS = 1;

  // Texturas
  const loader = new THREE.TextureLoader();
  const textures = pageImgs.map(src => loader.load(src));

  // ---- 3) Geometr√≠a subdividida (shared) ----
  // Crearemos una geometr√≠a centrada en 0,0, luego la "ajustamos" para pivot en el lomo:
  const geom = new THREE.PlaneGeometry(PAGE_W, PAGE_H, WIDTH_SEGMENTS, HEIGHT_SEGMENTS);

  // SHIFT: queremos que el lomo (hinge) est√© en la X = -PAGE_W/2
  // Para facilitar c√°lculos guardamos la posici√≥n original de v√©rtices
  const posAttr = geom.attributes.position;
  const vertexCount = posAttr.count;
  const original = new Float32Array(vertexCount * 3);
  for (let i=0;i<vertexCount;i++){
    original[i*3+0] = posAttr.getX(i);
    original[i*3+1] = posAttr.getY(i);
    original[i*3+2] = posAttr.getZ(i);
  }

  // ---- 4) Crear p√°ginas (front + back meshes) ----
  const pages = [];
  for (let i=0;i<textures.length;i++){
    // material frontal y posterior
    const matFront = new THREE.MeshPhongMaterial({ map: textures[i], side: THREE.FrontSide, shininess: 5 });
    // Para la cara trasera, usamos la textura de la p√°gina anterior (si existe), sino blanco
    const backTex = (i-1 >= 0) ? textures[i-1] : null;
    const matBack = new THREE.MeshPhongMaterial({
      map: backTex || null,
      color: backTex ? 0xffffff : 0xf8f5f2,
      side: THREE.FrontSide,
      shininess: 3
    });

    // dos meshes que comparten la misma geometr√≠a (para que la deformaci√≥n afecte a ambas)
    const frontMesh = new THREE.Mesh(geom, matFront);
    const backMesh  = new THREE.Mesh(geom, matBack);

    // back face: se voltea para que muestre su textura mirando al otro lado
    backMesh.rotation.y = Math.PI;
    backMesh.position.z = 0.001; // evitar z-fighting

    // Grupo contenedor para pivotar en el lomo (izquierda)
    const holder = new THREE.Group();
    // Para pivot en left edge: desplazamos el mesh hacia la derecha PAGE_W/2
    frontMesh.position.x = PAGE_W / 2;
    backMesh.position.x  = PAGE_W / 2;
    holder.add(frontMesh);
    holder.add(backMesh);

    // Posicionar el holder en el lomo (x = -PAGE_W/2 + offset por √≠ndice)
    const stackOffset = i * 0.35;
    holder.position.x = -PAGE_W/2 + stackOffset;
    holder.position.y = -6; // est√©tica
    holder.position.z = -i * 0.06;

    book.add(holder);
    pages.push({ holder, frontMesh, backMesh, index: i, progress: 0, flipping: false });
  }

  // est√©tica: rotar libro ligeramente
  book.rotation.y = 0.06;

  // ---- 5) Funciones de deformaci√≥n (curl) ----
  // Guardamos el bounding para calcular 'u' (0..1) a lo largo de la anchura de la p√°gina
  const leftX = -PAGE_W/2;
  const rightX = PAGE_W/2;
  const width = rightX - leftX;

  // copia original para restaurar
  const originalPositions = original; // alias

  // deformar la geometr√≠a en base a progress (0..1) y direction ('next' o 'prev')
  function deformGeometry(progress, direction = 'next') {
    // progress: 0 = plana, 1 = totalmente volteada
    const p = THREE.MathUtils.clamp(progress, 0, 1);
    const sign = (direction === 'next') ? -1 : 1; // next: rot hacia -y

    // par√°metros para curvado
    const curlStrength = 1.75;     // controla cu√°nto se curva la hoja
    const liftAmount = 18;         // cuanto se levanta del eje durante el movimiento
    const foldPos = 0.35 + 0.55 * p; // posici√≥n del "pliegue" relativa (0..1) desde el lomo

    // easing para suavizar la animaci√≥n
    const ease = t => t<0.5 ? 2*t*t : -1 + (4-2*t)*t;
    const ep = ease(p);

    // actualizar cada v√©rtice
    const pos = geom.attributes.position;
    for (let i = 0; i < vertexCount; i++) {
      const ox = originalPositions[i*3+0];
      const oy = originalPositions[i*3+1];
      const oz = originalPositions[i*3+2];

      // u = distancia desde el lomo en porcentaje (0 en lomo, 1 en borde exterior)
      const localX = ox - leftX; // (0..width)
      const u = localX / width;

      // Si volteamos 'next' (hoja derecha a izquierda), el lomo est√° a la izquierda (u small)
      // generamos curva que depende de la distancia al pliegue (foldPos)
      const distToFold = Math.abs(u - foldPos);
      // factor que aten√∫a curvado en regiones lejos del pliegue
      const falloff = Math.exp(-Math.pow(distToFold * 6.0, 2));

      // curvatura base (seno en funci√≥n de u para forma suave)
      const angle = ep * Math.PI * curlStrength; // √°ngulo global
      // Desplazamiento z: la hoja se dobla hacia +z o -z seg√∫n direcci√≥n
      const zCurl = Math.sin((u) * Math.PI) * angle * 6 * falloff * sign;
      // Elevaci√≥n y (para dar sensaci√≥n de 'levantamiento' en el centro del curl)
      const yLift = Math.sin(ep * Math.PI) * liftAmount * Math.sin(u * Math.PI) * falloff;

      // rotaci√≥n parcial alrededor del eje vertical del pliegue (aplicada como desplazamiento x/z).
      // Aproximaci√≥n: rotamos el punto alrededor de una l√≠nea vertical en la posici√≥n del pliegue
      // calculamos distancia angular local para simular rotaci√≥n
      const foldX = leftX + foldPos * width;
      const relX = ox - foldX;
      const rotLocal = ep * Math.PI * 0.99 * Math.exp(-u*3.2) * sign; // rotaci√≥n local suavizada
      const cosR = Math.cos(rotLocal), sinR = Math.sin(rotLocal);
      const rx = relX * cosR - zCurl * sinR;
      const rz = relX * sinR + zCurl * cosR;

      // reconstruimos posici√≥n final
      const finalX = foldX + rx;
      const finalY = oy + yLift * (1 - u*0.2); // menos lift cerca del borde
      const finalZ = rz;

      pos.setXYZ(i, finalX, finalY, finalZ);
    }
    pos.needsUpdate = true;
    geom.computeVertexNormals();
    geom.attributes.normal.needsUpdate = true;
  }

  // ---- 6) Flip controls / animaci√≥n ----
  let currentIndex = 0;
  const maxIndex = pages.length - 1;
  let animState = null;

  // helper anim: animates progress of a page
  function animateFlip(pageObj, toProgress, duration=600, direction='next', cb) {
    if (pageObj.flipping) return; // no stackear flips de la misma p√°gina
    pageObj.flipping = true;
    const from = pageObj.progress || 0;
    const start = performance.now();

    function frame(now){
      const t = Math.min(1, (now - start) / duration);
      // easeInOutCubic
      const ease = t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
      const prog = from + (toProgress - from) * ease;
      // Aplicar deformaci√≥n al mesh compartido
      deformGeometry(prog, direction);
      // rotaci√≥n global del holder para mejorar la ilusi√≥n:
      // rot around Y proportional to prog
      const holder = pageObj.holder;
      holder.rotation.y = (direction==='next') ? -Math.PI * prog * 0.99 : -Math.PI * (prog-1) * 0.99;
      // sutil elevaci√≥n
      holder.position.y = -6 + Math.sin(prog*Math.PI) * 6;

      renderer.render(scene, camera);
      if (t < 1) requestAnimationFrame(frame);
      else {
        pageObj.progress = toProgress;
        pageObj.flipping = false;
        if (cb) cb();
      }
    }
    requestAnimationFrame(frame);
  }

  // funci√≥n para pasar p√°gina hacia adelante (next)
  function goNext(){
    if (currentIndex >= maxIndex) return;
    const pageObj = pages[currentIndex];
    // flip this page from 0 -> 1
    animateFlip(pageObj, 1, 700, 'next', () => {
      // al final, incrementamos index y "reset" geometr√≠a plana (para siguiente flips)
      currentIndex++;
      // restaurar geometr√≠a a plana (no deformada) para la nueva p√°gina
      // restauramos posiciones originales
      const p = geom.attributes.position;
      for (let i=0;i<vertexCount;i++){
        p.setXYZ(i, originalPositions[i*3+0], originalPositions[i*3+1], originalPositions[i*3+2]);
      }
      p.needsUpdate = true;
      geom.computeVertexNormals();
      // reorden est√©tico Z
      for (let i=0;i<pages.length;i++){ pages[i].holder.position.z = -Math.abs(i - currentIndex) * 0.06; }
    });
  }

  // funci√≥n para ir atr√°s (prev)
  function goPrev(){
    if (currentIndex <= 0) return;
    // la p√°gina a "desvoltear" es currentIndex-1 (porque est√° volteada)
    const pageObj = pages[currentIndex-1];
    // animamos de 1 -> 0 con direcci√≥n 'prev'
    animateFlip(pageObj, 0, 700, 'prev', () => {
      currentIndex--;
      // restaurar geometr√≠a a plana
      const p = geom.attributes.position;
      for (let i=0;i<vertexCount;i++){
        p.setXYZ(i, originalPositions[i*3+0], originalPositions[i*3+1], originalPositions[i*3+2]);
      }
      p.needsUpdate = true;
      geom.computeVertexNormals();
      for (let i=0;i<pages.length;i++){ pages[i].holder.position.z = -Math.abs(i - currentIndex) * 0.06; }
    });
  }

  // botones
  document.getElementById('nextBtn').addEventListener('click', goNext);
  document.getElementById('prevBtn').addEventListener('click', goPrev);
  document.getElementById('resetBtn').addEventListener('click', ()=> {
    // devolver a portada
    const loop = () => { if (currentIndex>0) { goPrev(); setTimeout(loop, 250); } };
    loop();
  });

  // zone click / swipe
  renderer.domElement.addEventListener('click', (e) => {
    const w = renderer.domElement.clientWidth;
    if (e.clientX < w * 0.35) goPrev();
    else if (e.clientX > w * 0.65) goNext();
  });
  // swipe
  let sx = null;
  renderer.domElement.addEventListener('touchstart', (e)=> { sx = e.touches[0].clientX; }, {passive:true});
  renderer.domElement.addEventListener('touchend', (e)=> {
    if (sx===null) return;
    const dx = e.changedTouches[0].clientX - sx;
    if (dx < -30) goNext();
    else if (dx > 30) goPrev();
    sx = null;
  }, {passive:true});

  // ---- 7) loop render ----
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // resize
  window.addEventListener('resize', ()=> {
    const W = container.clientWidth, H = container.clientHeight;
    camera.aspect = W/H; camera.updateProjectionMatrix();
    renderer.setSize(W,H);
  });

  console.log("Libro 3D curvado listo. P√°ginas:", pages.length);

})(); // end IIFE
</script>

</body>
</html>
