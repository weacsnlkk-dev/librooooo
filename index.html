<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Libro 3D Curvado - Three.js</title>
<style>
  html, body {
    height: 100%; margin: 0; background: #f7efe3;
    font-family: Georgia, "Times New Roman", serif;
    overflow: hidden;
  }
  #container {
    width: 100%; height: 100vh;
    display: flex; align-items: center; justify-content: center;
  }
  /* Oculto las p√°ginas fuente */
  #page-source {
    position: fixed; left: -9999px; top: -9999px; visibility: hidden;
    width: 800px; height: 500px; padding: 30px; background: white;
    box-sizing: border-box; font-size: 18px; line-height: 1.6;
  }
  .cover h1 {
    color: #c2185b; font-size: 28px; margin: 0 0 10px; text-align: center;
  }
  .final-page img {
    max-width: 70%; display: block; margin: 12px auto;
  }
  /* Botones UI */
  #ui {
    position: fixed; right: 18px; bottom: 18px;
    display: flex; gap: 8px; z-index: 20;
  }
  .btn {
    background: #fff; border-radius: 8px; padding: 8px 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    cursor: pointer; user-select: none;
    font-weight: bold;
  }
</style>
</head>
<body>

<div id="container"></div>

<div id="page-source">
  <div class="page cover">
    <h1>üíå Feliz 10 meses amor...</h1>
    <p>Hoy quiero decirte que...</p>
  </div>

  <div class="page">
    Que siento miles de cosas en mi cabeza cada vez que te escucho hablarme bonito o de las cosas que te pasan, por m√°s que estos 10 meses no han pasado muchas cosas siento que te amo much√≠simo m√°s que desde un inicio y es algo s√∫per bonito y espero que‚Ä¶.
  </div>

  <div class="page">
    Te hayas dado cuenta de algo‚Ä¶ ese algo es lo lindo y especial que es pasar tiempo juntos por m√°s que sea tras una pantalla, sos todo lo que necesito en mi vida y la ni√±a que m√°s amar√© y me acordar√© si es que alg√∫n d√≠a pasa algo, yo a ti te valoro y te respeto un mont√≥n, tal vez alg√∫n d√≠a diremos "la distancia vali√≥ la pena".
    <br><br>
    El llegar a 10 meses en una relaci√≥n no es f√°cil, han pasado muchas cosas pero nunca pienso retroceder con vos, siento que encontr√© todo con vos y no te pienso soltar por solo un error de cualquiera de los dos. Tenemos demasiadas cosas en com√∫n pero algo que destaco es el escuchar y la comunicaci√≥n por m√°s que a veces nos cueste. Esto que pas√≥ hace poco del beso y no s√© qu√© m√°s espero que‚Ä¶.
  </div>

  <div class="page final-page">
    <img src="https://i.imgur.com/62b22f0d.jpg" alt="Snoopy adorable" />
    <p>No hayas pensado que eso puede decirme que sos una mala persona o que te ame menos por lo que pas√≥...</p>
  </div>
</div>

<div id="ui">
  <div class="btn" id="prevBtn">‚óÄ Anterior</div>
  <div class="btn" id="nextBtn">Siguiente ‚ñ∂</div>
  <div class="btn" id="resetBtn">‚Ü∫ Reset</div>
</div>

<!-- Librer√≠as -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/examples/js/controls/OrbitControls.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
(async () => {
  // Captura las p√°ginas como texturas (2x escala para nitidez)
  const pageDivs = [...document.querySelectorAll('#page-source .page')];
  const pageImgs = [];
  for (const div of pageDivs) {
    const canvas = await html2canvas(div, { width: 800, height: 500, scale: 2, backgroundColor: null });
    pageImgs.push(canvas.toDataURL('image/png'));
  }

  const container = document.getElementById('container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf7efe3);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  container.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 3000);
  camera.position.set(0, 60, 420);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enablePan = false;
  controls.minDistance = 300; controls.maxDistance = 900;
  controls.maxPolarAngle = Math.PI / 2.3;

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.85);
  hemiLight.position.set(0, 200, 0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(120, 200, 120);
  scene.add(dirLight);

  const book = new THREE.Group();
  scene.add(book);

  const PAGE_W = 200;
  const PAGE_H = PAGE_W * (500 / 800);
  const WIDTH_SEGMENTS = 60;
  const HEIGHT_SEGMENTS = 1;

  const loader = new THREE.TextureLoader();
  const textures = pageImgs.map(src => loader.load(src));

  const geom = new THREE.PlaneGeometry(PAGE_W, PAGE_H, WIDTH_SEGMENTS, HEIGHT_SEGMENTS);
  const posAttr = geom.attributes.position;
  const vertexCount = posAttr.count;
  const original = new Float32Array(vertexCount * 3);
  for (let i = 0; i < vertexCount; i++) {
    original[i * 3 + 0] = posAttr.getX(i);
    original[i * 3 + 1] = posAttr.getY(i);
    original[i * 3 + 2] = posAttr.getZ(i);
  }

  const pages = [];
  for (let i = 0; i < textures.length; i++) {
    const matFront = new THREE.MeshPhongMaterial({ map: textures[i], side: THREE.FrontSide, shininess: 5 });
    const backTex = (i - 1 >= 0) ? textures[i - 1] : null;
    const matBack = new THREE.MeshPhongMaterial({
      map: backTex || null,
      color: backTex ? 0xffffff : 0xf8f5f2,
      side: THREE.FrontSide,
      shininess: 3
    });

    const frontMesh = new THREE.Mesh(geom, matFront);
    const backMesh = new THREE.Mesh(geom, matBack);
    backMesh.rotation.y = Math.PI;
    backMesh.position.z = 0.001;

    const holder = new THREE.Group();
    frontMesh.position.x = PAGE_W / 2;
    backMesh.position.x = PAGE_W / 2;
    holder.add(frontMesh);
    holder.add(backMesh);

    const stackOffset = i * 0.35;
    holder.position.x = -PAGE_W / 2 + stackOffset;
    holder.position.y = -6;
    holder.position.z = -i * 0.06;

    book.add(holder);
    pages.push({ holder, frontMesh, backMesh, index: i, progress: 0, flipping: false });
  }

  book.rotation.y = 0.06;

  const leftX = -PAGE_W / 2;
  const rightX = PAGE_W / 2;
  const width = rightX - leftX;
  const originalPositions = original;

  function deformGeometry(progress, direction = 'next') {
    const p = THREE.MathUtils.clamp(progress, 0, 1);
    const sign = (direction === 'next') ? -1 : 1;

    const curlStrength = 1.75;
    const liftAmount = 18;
    const foldPos = 0.35 + 0.55 * p;

    const ease = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    const ep = ease(p);

    const pos = geom.attributes.position;
    for (let i = 0; i < vertexCount; i++) {
      const ox = originalPositions[i * 3 + 0];
      const oy = originalPositions[i * 3 + 1];
      const oz = originalPositions[i * 3 + 2];

      const localX = ox - leftX;
      const u = localX / width;

      const distToFold = Math.abs(u - foldPos);
      const falloff = Math.exp(-Math.pow(distToFold * 6.0, 2));

      const angle = ep * Math.PI * curlStrength;
      const zCurl = Math.sin(u * Math.PI) * angle * 6 * falloff * sign;
      const yLift = Math.sin(ep * Math.PI) * liftAmount * Math.sin(u * Math.PI) * falloff;

      const foldX = leftX + foldPos * width;
      const relX = ox - foldX;
      const rotLocal = ep * Math.PI * 0.99 * Math.exp(-u * 3.2) * sign;
      const cosR = Math.cos(rotLocal), sinR = Math.sin(rotLocal);
      const rx = relX * cosR - zCurl * sinR;
      const rz = relX * sinR + zCurl * cosR;

      const finalX = foldX + rx;
      const finalY = oy + yLift * (1 - u * 0.2);
      const finalZ = rz;

      pos.setXYZ(i, finalX, finalY, finalZ);
    }
    pos.needsUpdate = true;
    geom.computeVertexNormals();
    geom.attributes.normal.needsUpdate = true;
  }

  let currentIndex = 0;
  const maxIndex = pages.length - 1;

  function animateFlip(pageObj, toProgress, duration = 600, direction = 'next', cb) {
    if (pageObj.flipping) return;
    pageObj.flipping = true;
    const from = pageObj.progress || 0;
    const start = performance.now();

    function frame(now) {
      const t = Math.min(1, (now - start) / duration);
      const ease = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      const prog = from + (toProgress - from) * ease;
      deformGeometry(prog, direction);
      const holder = pageObj.holder;
      holder.rotation.y = (direction === 'next') ? -Math.PI * prog * 0.99 : -Math.PI * (prog - 1) * 0.99;
      holder.position.y = -6 + Math.sin(prog * Math.PI) * 6;

      renderer.render(scene, camera);
      if (t < 1) requestAnimationFrame(frame);
      else {
        pageObj.progress = toProgress;
        pageObj.flipping = false;
        if (cb) cb();
      }
    }
    requestAnimationFrame(frame);
  }

  function goNext() {
    if (currentIndex >= maxIndex) return;
    const pageObj = pages[currentIndex];
    animateFlip(pageObj, 1, 700, 'next', () => {
      currentIndex++;
      const p = geom.attributes.position;
      for (let i = 0; i < vertexCount; i++) {
        p.setXYZ(i, originalPositions[i * 3 + 0], originalPositions[i * 3 + 1], originalPositions[i * 3 + 2]);
      }
      p.needsUpdate = true;
      geom.computeVertexNormals();
      for (let i = 0; i < pages.length; i++) {
        pages[i].holder.position.z = -Math.abs(i - currentIndex) * 0.06;
      }
    });
  }

  function goPrev() {
    if (currentIndex <= 0) return;
    const pageObj = pages[currentIndex - 1];
    animateFlip(pageObj, 0, 700, 'prev', () => {
      currentIndex--;
      const p = geom.attributes.position;
      for (let i = 0; i < vertexCount; i++) {
        p.setXYZ(i, originalPositions[i * 3 + 0], originalPositions[i * 3 + 1], originalPositions[i * 3 + 2]);
      }
      p.needsUpdate = true;
      geom.computeVertexNormals();
      for (let i = 0; i < pages.length; i++) {
        pages[i].holder.position.z = -Math.abs(i - currentIndex) * 0.06;
      }
    });
  }

  document.getElementById('nextBtn').addEventListener('click', goNext);
  document.getElementById('prevBtn').addEventListener('click', goPrev);
  document.getElementById('resetBtn').addEventListener('click', () => {
    while (currentIndex > 0) {
      goPrev();
    }
  });

  renderer.domElement.addEventListener('click', e => {
    const w = renderer.domElement.clientWidth;
    if (e.clientX < w * 0.35) goPrev();
    else if (e.clientX > w * 0.65) goNext();
  });

  let sx = null;
  renderer.domElement.addEventListener('touchstart', e => { sx = e.touches[0].clientX; }, { passive: true });
  renderer.domElement.addEventListener('touchend', e => {
    if (sx === null) return;
    const dx = e.changedTouches[0].clientX - sx;
    if (dx < -30) goNext();
    else if (dx > 30) goPrev();
    sx = null;
  }, { passive: true });

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    const W = container.clientWidth, H = container.clientHeight;
    camera.aspect = W / H; camera.updateProjectionMatrix();
    renderer.setSize(W, H);
  });

  console.log("Libro 3D curvado listo. P√°ginas:", pages.length);
})();
</script>

</body>
</html>
